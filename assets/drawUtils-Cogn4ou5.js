import{h5 as b,cX as d,h6 as P,h7 as A,y as B,h8 as v,bS as C,h9 as D,ha as q,hb as z,hc as U,hd as E,he as F}from"./index-tyY3opuW.js";import{c as G}from"./GraphicManipulator-nBvAOlVN.js";function R(n,e,s,t){if(n.type==="point")return n.x+=e,n.y+=s,n.hasZ&&t!=null,n;if(n.type==="multipoint"){const r=n.points;for(let o=0;o<r.length;o++)r[o]=w(r[o],e,s,t);return n}if(n.type==="extent")return n.xmin+=e,n.xmax+=e,n.ymin+=s,n.ymax+=s,n;const i=n.type==="polyline"?n.curvePaths??n.paths:n.curveRings??n.rings,c=D(n);for(let r=0;r<i.length;r++){const o=i[r];for(let y=0;y<o.length;y++)o[y]=I(o[y],e,s,t)}return"paths"in n?c?n.curvePaths=i:n.paths=i:c?n.curveRings=i:n.rings=i,n}function N(n,e,s,t,i){const c=n.clone();if(i){const{resolution:r}=t;R(c,e*r,-s*r)}else{const{dxMap:r,dyMap:o}=H(e,s,t);R(c,r,o)}return c}function H(n,e,s){const t=s.state.inverseTransform;return{dxMap:t[0]*n+t[2]*e,dyMap:t[1]*n+t[3]*e}}function w(n,e,s,t){return S(n,n[0]+e,n[1]+s,n[2]!=null&&t!=null?n[2]+t:void 0)}function I(n,e,s,t){const i=w(v(n),e,s,t);if(q(n))return i;if(z(n)){const[,o,y]=n.b;return{b:[i,[o[0]+e,o[1]+s],[y[0]+e,y[1]+s]]}}if(U(n)){const[,o]=n.c;return{c:[i,[o[0]+e,o[1]+s]]}}const[,c,...r]=n.a;return{a:[i,[c[0]+e,c[1]+s],...r]}}function O(n,e,s,t){if(n.type==="point"){const{x:u,y:f}=n,x=t?t[0]:u,l=t?t[1]:f,h=n.clone(),m=(u-x)*e+x,a=(f-l)*s+l;return h.x=m,h.y=a,h}if(n.type==="extent"){const{xmin:u,xmax:f,ymin:x,ymax:l}=n,h=t?t[0]:(u+f)/2,m=t?t[1]:(l+x)/2,a=n.clone();if(a.xmin=(u-h)*e+h,a.ymax=(l-m)*s+m,a.xmax=(f-h)*e+h,a.ymin=(x-m)*s+m,a.xmin>a.xmax){const p=a.xmin,M=a.xmax;a.xmin=M,a.xmax=p}if(a.ymin>a.ymax){const p=a.ymin,M=a.ymax;a.ymin=M,a.ymax=p}return a}let i=null;if(!t){i=b(n);const u=d(),f=P(u,i);if(!f)return n.clone();const[x,l,h,m]=f;t=[(x+h)/2,(l+m)/2]}const[c,r]=t;if(n.type==="multipoint"){const u=n.clone(),f=u.points;for(let x=0;x<f.length;x++){const l=f[x],[h,m]=l,a=(h-c)*e+c,p=(m-r)*s+r;f[x]=S(l,a,p,void 0)}return u.points=f,u}const o=n.clone();i??=b(n);const y=o.type==="polygon",g=y?o.curveRings??o.rings:o.curvePaths??o.paths;if(!t){const u=d(),f=P(u,g,!1,!1);if(!f)return o;t=A(f)}for(const u of g){let f=null;const x=y&&u.length>0&&B(v(u[0]),v(u.at(-1)));for(let l=0;l<u.length;l++){const h=u[l];u[l]=J(h,e,s,c,r,f),f=h}x&&(u[0]=[...v(u.at(-1))])}return o}function j(n,e,s,t,i){const[c,r,...o]=n;return[(c-t)*e+t,(r-i)*s+i,...o]}function J(n,e,s,t,i,c){if(q(n))return j(n,e,s,t,i);if(z(n)){const[T,X,Z]=n.b.map(k=>j(k,e,s,t,i));return{b:[T,X,Z]}}if(!c)return n;const r=v(c),o=U(n)?E(r,n):n,[y,g,u,f,x,l,h]=o.a,m=x??0,a=l??Math.hypot(y[0]-g[0],y[1]-g[1]),p=h??1,M=G(t,i,1,0,0,1,e,s);return F(r,{a:[[...y],[...g],u,f,m,a,p]},M)}function Q(n,e,s,t,i,c){const r=Math.sqrt((s-n)*(s-n)+(t-e)*(t-e));return Math.sqrt((i-n)*(i-n)+(c-e)*(c-e))/r}function V(n,e,s,t=!1){const i=Math.atan2(e.y-s.y,e.x-s.x)-Math.atan2(n.y-s.y,n.x-s.x),c=Math.atan2(Math.sin(i),Math.cos(i));return t?c:C(c)}function S(n,e,s,t){const i=[e,s];return n.length>2&&i.push(t??n[2]),n.length>3&&i.push(n[3]),i}export{O as M,Q as U,V as b,H as h,N as x};
